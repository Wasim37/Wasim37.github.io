---
title: Python 一切皆对象
categories:
  - 其他
tags:
  - 面向对象
date: 2017-3-20 21:18:00
toc: true

---

Python从设计之初就是一门面向对象的语言，它有一个重要的概念，即一切皆对象。

Java虽然也是面向对象编程的语言，但是血统没有Python纯正。比如Java的八种基本数据类型之一int，在持久化的时候，就需要包装成Integer类对象。但是在python中，一切皆对象。数字、字符串、元组、列表、字典、函数、方法、类、模块等等都是对象，包括你的代码。

---

### 对象的概念

究竟何谓对象？不同的编程语言以不同的方式定义“对象”。某些语言中，它意味着所有对象必须有属性和方法；另一些语言中，它意味着所有的对象都可以子类化。

在Python中，定义是松散的，某些对象既没有属性也没有方法，而且不是所有的对象都可以子类化。但是Python的万物皆对象从感性上可以解释为：**Python 中的一切都可以赋值给变量或者作为参数传递给函数。**

Python 的所有对象都有三个特性：

- 身份：每个对象都有一个唯一的身份标识自己，任何对象的身份都可以使用内建函数 id() 来得到，可以简单的认为这个值是该对象的内存地址。
```bash
>>> a = 1
>>> id(a)
>>> 26188904                        # 身份由这样一串类似的数字表示
```

<!-- more -->

- 类型：对象的类型决定了对象可以保存什么类型的值，有哪些属性和方法，可以进行哪些操作，遵循怎样的规则。可以使用内建函数 type() 来查看对象的类型。
```bash
>>> type(a)
<type 'int'>
>>> type(type)
<type 'type'>                         #万物皆对象，type 也是一种特殊的对象 type
```

- 值：对象所表示的数据
```bash
>>> a
1
```
"身份"、"类型"和"值"在所有对象创建时被赋值。如果对象支持更新操作，则它的值是可变的，否则为只读（数字、字符串、元组等均不可变）。只要对象还存在，这三个特性就一直存在。

对象的属性：大部分 Python 对象有属性、值或方法，使用句点（.）标记法来访问属性。最常见的属性是函数和方法，一些 Python 对象也有数据属性，如：类、模块、文件等

---

### 对象的创建和引用
```bash
>>> a = 3
```

简单来看，上边的代码执行了以下操作：

- 创建了一个对象来代表数字 3
- 如果变量 a 不存在，创建一个新的变量 a
- 将变量 a 和数字 3 进行连接，即 a 成为对象 3 的一个引用，从内部来看，变量是到对象的内存空间的一个指针，<font style="color:red">尤其注意：变量总是连接到对象，而不会连接到其他变量。</font>

从概念上可以这样理解，对象是堆上分配的一个内存空间，用来表示对象所代表的值；变量是一个系统创建的表中的元素，拥有指向对象的引用；引用是从变量到对象的指针。

**从技术上来说，每一个对象有两个标准的头部信息，一个类型标识符来标识类型，还有一个引用的计数器，用于决定是否需要对对象进行回收。这里还涉及到对象的一种优化方法，Python 缓存了某些不变的对象对其进行复用，而不是每次创建新的对象。**
```bash
>>> a = 1
>>> b = 1
>>> id(a)
26188904
>>> id(b)
26188904                                             # a 和 b 都指向了同一对象
```

---

### 共享引用

在 Python 中变量都是指向某一对象的引用，当多个变量都引用了相同的对象，成为共享引用。
```bash
>>> a = 1
>>> b = a
>>> a = 2
>>> b
1                       # 由于变量仅是对对象的一个引用，因此改变 a 并不会导致 b 的变化
```

但对于像列表这种可变对象来说则不同
```bash
>>> a = [1, 2, 3]
>>> b = a
>>> a[0] = 0
>>> a
[0, 2, 3]            # 这里并没有改变 a 的引用，而是改变了被引用对象的某个元素
>>> b
[0, 2, 3]            # 由于被引用对象发生了变化，因此 b 对应的值也发生了改变
```

由于列表的这种可变性，在代码执行某些操作时可能出现一些意外，因此需要对其进行拷贝来保持原来的列表
```bash
>>> a = [1, 2, 3]
>>> b = a[:]
>>> id(a)
140200275166560
>>> id(b)
140200275238712             # 由于 b 引用的是 a 引用对象的一个拷贝，两个变量指向的内存空间不同
>>> a[0] = 0
>>> b
[1, 2, 3]                   # 改变 a 中的元素并不会引起 b 的变化
```

对于字典和集合等没有分片概念的类型来说，可以使用 copy 模块中的 copy() 方法进行拷贝

```bash
>>> import copy
>>> b = copy.copy(a)
```

python深度拷贝与浅拷贝可移步：http://blog.csdn.net/yugongpeng_blog/article/details/46604439

---

### 对象相等

== 操作符用于测试两个被引用的对象的值是否相等
is 用于比较两个被引用的对象是否是同一个对象
```bash
>>> a = [1, 2, 3]
>>> b = a
>>> a is b
True               # a 和 b 指向相同的对象
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> a is b
False               # a 和 b 指向不同的对象
```

当操作对象为一个较小的数字或较短的字符串时，又有不同：
```bash
>>> a = 7
>>> b = 7
>>> a is b
True               # a 和 b 指向相同的对象
```

<font style="color:red">这是由于 Python 的缓存机制造成的，小的数字和字符串被缓存并复用，所以 a 和 b 指向同一个对象</font>

---

### 对象回收机制

上边提到对象包含一个引用的计数器，计数器记录了当前指向该对象引用的数目，一旦对象的计数器为 0 ，即不存在对该对象的引用，则这个对象的内存空间会被回收。这就是 Python 中对象的回收机制，一个最明显的好处即在编写代码过程中不需要考虑释放内存空间。

可以通过 sys 模块中的 getrefcount() 函数查询一个对象计数器的值
```bash
>>> import sys
>>> sys.getrefcount(1)
718
```